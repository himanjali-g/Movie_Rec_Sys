````markdown
# BingeBuddy - Your Ultimate Movie Recommender System ğŸ¬

## ğŸŒŸ Overview

BingeBuddy is a content-based movie recommender system designed to help you discover your next favorite film. By analyzing movie content such as plot summaries, genres, keywords, cast, and crew, BingeBuddy suggests movies that are similar to the ones you already love.

This project uses a dataset from The Movie Database (TMDB) and leverages Natural Language Processing (NLP) techniques to understand movie content and calculate similarity. The final application is deployed as an interactive web app using Streamlit.

**Live App Demo:** [Link to your deployed Streamlit App (if available)]

## âœ¨ Features

* **Content-Based Recommendations:** Get movie suggestions based on intrinsic properties like genre, plot, cast, and director.
* **Interactive UI:** A simple and clean user interface built with Streamlit allows users to easily select a movie and get instant recommendations.
* **Dynamic Poster Fetching:** The app dynamically fetches and displays movie posters using the TMDB API for a visually engaging experience.
* **Scalable Model:** The core recommendation logic is pre-computed and saved, ensuring fast recommendation times for the end-user.

## ğŸ¤– How It Works

The recommendation engine is built on the principle of "content-based filtering." The similarity between movies is determined by comparing their content tags.

1.  **Data Collection:** The project uses the [TMDB 5000 Movie Dataset](https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata).
2.  **Data Preprocessing:** The initial datasets (`tmdb_5000_movies.csv` and `tmdb_5000_credits.csv`) are merged. Key features like `genres`, `overview`, `keywords`, `cast` (top 3 actors), and `crew` (director) are extracted and cleaned.
3.  **Feature Engineering:** All the extracted text-based features are combined into a single "tags" corpus for each movie. This corpus represents the movie's content DNA.
4.  **Text Vectorization:** The "tags" for all movies are converted into numerical vectors using the **Bag of Words** technique (`CountVectorizer`). This process creates a high-dimensional vector space where each movie is a point.
5.  **Similarity Calculation:** The **Cosine Similarity** metric is used to calculate the similarity between every pair of movie vectors. A higher cosine similarity score means the movies are more similar in content.
6.  **Recommendation:** When a user selects a movie, the system finds its corresponding vector and returns the top 8 most similar movies based on the pre-computed similarity scores.

## ğŸ› ï¸ Technical Stack

* **Python 3.x**
* **Pandas & NumPy:** For data manipulation and numerical operations.
* **Scikit-learn:** For text vectorization (`CountVectorizer`) and similarity calculation (`cosine_similarity`).
* **NLTK:** For stemming text to its root words.
* **Streamlit:** To build and deploy the interactive web application.
* **Requests:** For making API calls to TMDB to fetch movie posters.
* **Jupyter Notebook:** For the initial data analysis, model building, and experimentation.
* **Pickle:** For saving the processed data and similarity matrix.

## ğŸ“‚ File Structure
````

â”œâ”€â”€ BingeBuddy (1).ipynb    \# Jupyter Notebook with the core logic for the recommender.
â”œâ”€â”€ app.py                  \# Streamlit script for the web application UI.
â”œâ”€â”€ movie\_dict.pkl          \# Serialized Python dictionary of processed movie data (generated by notebook).
â”œâ”€â”€ similarity.pkl          \# Serialized cosine similarity matrix (generated by notebook).
â”œâ”€â”€ tmdb\_5000\_movies.csv    \# Original movie dataset.
â”œâ”€â”€ tmdb\_5000\_credits.csv   \# Original credits dataset.
â”œâ”€â”€ logo.jpg                \# Logo for the web app.
â””â”€â”€ README.md               \# You are here\!

```
```
